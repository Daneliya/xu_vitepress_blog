---
title: 给AI模型用工具的能力
tags:
  - Python
categories:
  - Python
---



## 一、ReAct AI不仅长脑子，还能长手

大语言模型的知识受限于训练数据（存在 “知识截止期”），无法回答训练后发生的事件或实时信息。而 REACT 框架通过 “推理（Reason）+ 行动（Action）” 的协同模式，让模型像人类一样通过与外部工具交互（如搜索、调用 API）获取新知识，突破固有局限。以下从核心原理、工作流程、应用价值三方面展开：

### 1、REACT 框架的核心：推理与行动的结合

REACT（Reason + Action）框架由 2022 年同名论文提出，核心逻辑是**让模型通过动态推理决定何时采取行动，并利用外部工具获取信息**，而非仅依赖内部知识。

- **解决的问题**：模型知识过时（如无法回答训练后发生的事件）、无法验证信息真实性等局限。
- **核心思路**：模仿人类解决问题的流程 —— 先思考（推理）→ 再行动（如搜索）→ 观察结果→ 继续思考→ 最终解决问题。

### 2、REACT 的工作流程：以 “2022 年欧冠冠军” 为例

假设模型知识截止到 2022 年 1 月，需回答 “2022 年欧冠冠军是哪支球队”，其步骤如下：

#### 1. 推理（Reason）

模型分析问题：“2022 年欧冠决赛在我知识截止后举行，需要最新信息，应通过搜索获取。”

#### 2. 行动（Action）

基于推理采取行动：调用搜索引擎，搜索关键词 “2022 UEFA Champions League champion”。

#### 3. 观察（Observation）

获取行动结果：搜索返回多个网页，其中某新闻标题提到 “2022 欧冠决赛：皇马击败利物浦夺冠”。

#### 4. 再推理

分析观察结果：“该新闻链接可能包含详细赛果，需进一步查看。”

#### 5. 再行动

点击该新闻链接，获取具体信息（如比分、关键球员等）。

#### 6. 最终推理与行动

整理信息：“确认皇马为 2022 年欧冠冠军，可总结结果并回复用户。”

### 3、REACT 框架的关键价值

1. **突破知识截止期**
   通过与搜索引擎、实时数据库等工具交互，模型能获取训练后的数据（如最新新闻、赛事结果），回答 “时效性问题”。
2. **提升信息可信度**
   行动步骤（如搜索链接、引用来源）让信息可追溯，用户可验证答案真实性，减少模型 “幻觉”。
3. **适配多场景工具**
   “行动” 不仅限于搜索，还可扩展至：
   - 调用代码解释器（运行代码解决数学问题）；
   - 访问本地文档（检索知识库内容）；
   - 调用第三方 API（如查询天气、股票数据）。
4. **透明化推理过程**
   思维链（Chain of Thought）式的分步推理，让模型的决策过程可观察、可解释，便于调试和优化。

### 4、与传统模型的对比

| 维度     | 传统大语言模型       | 基于 REACT 框架的模型            |
| -------- | -------------------- | -------------------------------- |
| 知识来源 | 仅依赖训练数据       | 训练数据 + 外部工具实时信息      |
| 时效性   | 受限于知识截止期     | 可获取实时信息                   |
| 信息验证 | 无法验证，易产生幻觉 | 可通过行动追溯来源，验证真实性   |
| 适用场景 | 通用问答、创作等     | 实时查询、复杂问题解决、工具交互 |

REACT 框架的核心是让 AI 从 “被动回答” 变为 “主动解决问题”，通过推理与行动的循环，扩展能力边界。下一节将具体讲解如何为模型集成工具（如搜索引擎、API），实现 REACT 的落地。



## 二、Agent 自定义你的AI工具

基于 REACT（Reason + Action）框架的 Agent（智能体），能让大语言模型通过 “推理→行动→观察” 的循环与外部工具交互，突破固有局限（如计算能力不足、知识过时等）。以下从**核心概念、实现步骤、代码示例**三方面，详解如何用 LangChain 构建 Agent：

### 1、Agent 的核心逻辑与组件

Agent 的本质是 “具备决策能力的大语言模型”，通过工具扩展能力，核心流程遵循 “推理→行动→观察” 循环：

#### 1. 核心组件

- **大语言模型（LLM）**：Agent 的 “大脑”，负责推理决策（如判断是否需要工具、选择哪种工具）。
- **工具（Tools）**：Agent 可调用的外部能力（如计算函数、搜索引擎、API 等），补充模型缺陷。
- **提示模板（Prompt Template）**：引导模型遵循 REACT 框架，明确推理步骤、工具使用规则。
- **Agent 执行器（Agent Executor）**：协调 Agent 与工具的交互，执行行动并返回结果。

#### 2. 工作流程

1. **推理（Reason）**：模型分析用户问题，判断是否需要工具（如 “计算文本字数” 需调用工具，“介绍巴黎” 可直接回答）。
2. **行动（Action）**：若需工具，Agent 生成行动指令（如调用`TextLengthTool`，传入文本参数），由执行器调用工具。
3. **观察（Observation）**：获取工具返回结果（如 “该文本共 120 字”），作为新信息输入模型。
4. **循环迭代**：模型基于观察结果再次推理，直至认为问题解决，返回最终答案。

### 2、用 LangChain 实现 Agent 的步骤

以 “文本字数计算 Agent” 为例（解决模型直接计算易出错的问题），具体实现如下：

#### 1. 准备工作：安装依赖

~~~sh
pip install langchain langchain-openai langchainhub  # 核心库：LangChain、OpenAI、提示模板库
~~~

#### 2. 定义大语言模型（LLM）

选择适合推理的模型，降低随机性（`temperature`设为 0.1）：

~~~python
from langchain_openai import ChatOpenAI

# 初始化模型（Agent的“大脑”）
llm = ChatOpenAI(
    model_name="gpt-3.5-turbo",
    openai_api_key="你的API密钥",
    temperature=0.1  # 减少随机性，确保遵循REACT框架
)
~~~

#### 3. 定义工具（Tool）

工具需继承`BaseTool`，并明确名称、描述和功能（此处实现 “文本字数计算工具”）：

~~~python
from langchain.tools import BaseTool
from typing import Optional, Type
from pydantic import BaseModel, Field

# 定义工具输入参数（可选，用于规范输入格式）
class TextLengthInput(BaseModel):
    text: str = Field(description="需要计算字数的文本")

# 实现文本字数计算工具
class TextLengthTool(BaseTool):
    name = "TextLengthTool"  # 工具名称（模型需通过名称调用）
    description = "用于计算文本的字数，输入为字符串，返回字数"  # 工具功能描述
    args_schema: Type[BaseModel] = TextLengthInput  # 输入参数 schema

    def _run(self, text: str) -> int:
        # 工具核心逻辑：返回文本字数
        return len(text)

    def _arun(self, text: str):
        # 异步方法（可选，此处省略）
        raise NotImplementedError("暂不支持异步调用")

# 创建工具实例
tools = [TextLengthTool()]  # 工具列表（可包含多个工具）
~~~

#### 4. 获取 REACT 提示模板

从`LangChainHub`获取官方 REACT 框架提示模板（无需手动编写）：

~~~python
from langchain import hub

# 拉取结构化对话Agent的提示模板（遵循REACT框架）
prompt = hub.pull("hwchase17/structured-chat-agent")  # hwchase17为LangChain CEO
# 模板内容：引导模型推理、使用工具、处理观察结果
~~~

#### 5. 初始化 Agent

将模型、工具、提示模板整合为 Agent：

~~~python
from langchain.agents import create_structured_chat_agent

# 创建遵循REACT框架的结构化对话Agent
agent = create_structured_chat_agent(
    llm=llm,
    tools=tools,
    prompt=prompt
)
~~~

#### 6. 定义 Agent 执行器（Agent Executor）

负责调度 Agent 与工具，处理错误和日志：

~~~python
from langchain.agents import AgentExecutor

# 创建执行器（实际运行Agent的组件）
agent_executor = AgentExecutor.from_agent_and_tools(
    agent=agent,
    tools=tools,
    verbose=True,  # 详细模式：打印推理、行动、观察过程
    handle_parsing_errors=True,  # 自动处理解析错误（让模型自行修正）
    # memory=memory  # 可选：添加对话记忆（需提前初始化）
)
~~~

### 3、使用 Agent 解决问题

#### 1. 调用 Agent 计算文本字数

~~~python
# 提问：计算指定文本的字数
response = agent_executor.invoke({
    "input": "请计算文本'LangChain是一个强大的AI框架'的字数"
})

print(response["output"])  # 输出：13（正确结果）
~~~

#### 2. 执行过程解析（`verbose=True`时打印）

~~~python
> 推理：用户需要计算文本字数，我应该使用TextLengthTool工具，输入文本为'LangChain是一个强大的AI框架'。
> 行动：{"action": "TextLengthTool", "action_input": {"text": "LangChain是一个强大的AI框架"}}
> 观察：13
> 推理：工具返回结果为13，已得到答案，无需进一步行动。
> 输出：该文本的字数为13。
~~~

#### 3. 处理无需工具的问题

~~~python
# 提问：无需工具的问题
response = agent_executor.invoke({
    "input": "巴黎是哪个国家的首都？"
})

print(response["output"])  # 输出：巴黎是法国的首都。（直接回答，不调用工具）
~~~

#### 4、完整代码示例

~~~python
# 导入所需模块
from langchain import hub  # 用于获取提示模板
from langchain.agents import create_structured_chat_agent, AgentExecutor  # 创建Agent和执行器
from langchain.memory import ConversationBufferMemory  # 对话记忆
from langchain.schema import HumanMessage  # 人类消息格式
from langchain.tools import BaseTool  # 工具基类
from langchain_openai import ChatOpenAI  # OpenAI聊天模型

# 初始化GPT-3.5模型，temperature=0表示输出更确定
model = ChatOpenAI(model='gpt-3.5-turbo', temperature=0)

# 直接调用模型计算字数（可能不准确，展示模型局限性）
model.invoke([HumanMessage(content="'君不见黄河之水天上来奔流到海不复回'，这句话的字数是多少？")])

# 定义文本字数计算工具（继承BaseTool）
class TextLengthTool(BaseTool):
    name = "文本字数计算工具"  # 工具名称
    description = "当你被要求计算文本的字数时，使用此工具"  # 工具描述（帮助模型判断何时使用）

    # 工具核心逻辑：计算输入文本的长度
    def _run(self, text):
        return len(text)

# 创建工具列表（可包含多个工具）
tools = [TextLengthTool()]

# 从LangChainHub获取结构化对话Agent的提示模板（遵循REACT框架）
prompt = hub.pull("hwchase17/structured-chat-agent")
prompt  # 查看模板内容

# 创建结构化聊天Agent（整合模型、工具、提示模板）
agent = create_structured_chat_agent(
    llm=model,
    tools=tools,
    prompt=prompt
)

# 初始化对话记忆（保存历史对话）
memory = ConversationBufferMemory(
        memory_key='chat_history',  # 记忆在Agent中的键名
        return_messages=True  # 以消息对象形式存储
)

# 创建Agent执行器（负责运行Agent并调用工具）
agent_executor = AgentExecutor.from_agent_and_tools(
    agent=agent, 
    tools=tools, 
    memory=memory,  # 关联记忆
    verbose=True,  # 详细模式：打印推理过程
    handle_parsing_errors=True  # 自动处理解析错误
)

# 调用Agent计算诗句字数（会使用工具，结果准确）
agent_executor.invoke({"input": "'君不见黄河之水天上来奔流到海不复回'，这句话的字数是多少？"})

# 调用Agent回答无需工具的问题（直接回答，不调用工具）
agent_executor.invoke({"input": "请你充当我的物理老师，告诉我什么是量子力学"})
~~~



### 4、关键扩展与注意事项

1. **添加对话记忆**
   初始化`ConversationBufferMemory`，传入`agent_executor`，支持多轮对话（如 “上一个文本的字数是多少？”）。
2. **扩展工具类型**
   工具不仅限于计算，还可集成：
   - 搜索引擎（`SerpAPI`）：获取实时信息；
   - 代码解释器（`PythonREPLTool`）：解决数学问题；
   - 文档检索工具：查询本地知识库。
3. **错误处理**
   `handle_parsing_errors=True`可处理大部分格式错误，但模型输出仍可能不稳定，建议复杂场景添加重试机制。
4. **Verbose 模式**
   开发阶段设为`True`，便于调试推理过程；生产环境设为`False`，隐藏中间步骤。

通过 LangChain 实现的 REACT 框架 Agent，让模型从 “被动回答” 升级为 “主动解决问题”，结合工具扩展能力边界，可应用于实时查询、复杂任务处理等场景。



## 三、Tool 用现成的AI工具运行代码

大语言模型直接进行数学计算时容易出错（本质是预测下一个 Token，而非真正计算）。通过集成 Python 解释器，让 AI 生成代码并执行，可解决这一问题 —— 这一思路基于**Program-Aided Language Models（PoL，程序辅助语言模型）** 框架。以下是具体实现与核心逻辑：

### 1、PoL 框架的核心：用代码替代直接计算

PoL 框架（2022 年论文提出）的核心逻辑是：**让 AI 生成解决问题的代码，而非直接输出答案**，通过执行代码得到准确结果。适用于：

- 复杂数学计算（如高精度小数运算、数列求解）；
- 数据处理（如统计、图表生成）；
- 逻辑推理（如递归问题、条件判断）

**优势**：相比模型直接猜测答案，代码执行结果更可靠，尤其避免 “计算幻觉”（如错误的订单金额、数学结果）。

### 2、实现步骤：用 LangChain 创建 Python 解释器 Agent

#### 2.1. 安装依赖

需安装`langchain-experimental`（含 Python 解释器工具）：

~~~sh
pip install langchain-experimental
~~~

#### 2.2. 核心组件准备

##### （1）初始化大语言模型

选择低随机性模型（`temperature=0`），确保生成的代码规范：

~~~python
from langchain_openai import ChatOpenAI

# 模型作为Agent的“大脑”，负责生成代码
llm = ChatOpenAI(
    model_name="gpt-3.5-turbo",
    openai_api_key="你的API密钥",
    temperature=0  # 减少随机性，确保代码逻辑严谨
)
~~~

##### （2）导入 Python 解释器工具

使用`langchain-experimental`提供的`PythonREPLTool`（交互式 Python 解释器）：

~~~python
from langchain_experimental.tools import PythonREPLTool

# 工具：用于执行AI生成的Python代码
python_repl = PythonREPLTool()  # 无需自定义，直接使用现成工具
~~~

#### 2.3. 创建 Python Agent 执行器

借助`create_python_agent`函数快速构建 Agent（自动整合模型、工具和 PoL 提示模板）：

~~~python
from langchain_experimental.agents import create_python_agent
from langchain.agents import AgentType

# 创建能执行Python代码的Agent执行器
agent_executor = create_python_agent(
    llm=llm,
    tool=python_repl,
    agent_type=AgentType.ZERO_SHOT_REACT_DESCRIPTION,  # 遵循REACT框架
    verbose=True,  # 打印代码生成与执行过程
    agent_executor_kwargs={"handle_parsing_errors": True}  # 自动处理代码解析错误
)
~~~

### 3、实战案例：用 Agent 解决数学问题

#### 3.1、前置代码

~~~python
#!pip install langchain_experimental
from langchain_experimental.agents.agent_toolkits import create_python_agent
from langchain_experimental.tools import PythonREPLTool
from langchain_openai import ChatOpenAI

tools = [PythonREPLTool()]

agent_executor = create_python_agent(
    llm=ChatOpenAI(model="gpt-3.5-turbo", temperature=0),
    tool=PythonREPLTool(),
    verbose=True,
    agent_executor_kwargs={"handle_parsing_errors": True}
)

agent_executor
~~~

~~~sh
AgentExecutor(verbose=True, agent=ZeroShotAgent(llm_chain=LLMChain(prompt=PromptTemplate(input_variables=['agent_scratchpad', 'input'], template='You are an agent designed to write and execute python code to answer questions.\nYou have access to a python REPL, which you can use to execute python code.\nIf you get an error, debug your code and try again.\nOnly use the output of your code to answer the question. \nYou might know the answer without running any code, but you should still run the code to get the answer.\nIf it does not seem like you can write code to answer the question, just return "I don\'t know" as the answer.\n\n\nPython_REPL: A Python shell. Use this to execute python commands. Input should be a valid python command. If you want to see the output of a value, you should print it out with `print(...)`.\n\nUse the following format:\n\nQuestion: the input question you must answer\nThought: you should always think about what to do\nAction: the action to take, should be one of [Python_REPL]\nAction Input: the input to the action\nObservation: the result of the action\n... (this Thought/Action/Action Input/Observation can repeat N times)\nThought: I now know the final answer\nFinal Answer: the final answer to the original input question\n\nBegin!\n\nQuestion: {input}\nThought:{agent_scratchpad}'), llm=ChatOpenAI(client=<openai.resources.chat.completions.Completions object at 0x122912c90>, async_client=<openai.resources.chat.completions.AsyncCompletions object at 0x12291e150>, temperature=0.0, openai_api_key=SecretStr('**********'), openai_proxy='')), output_parser=MRKLOutputParser(), allowed_tools=['Python_REPL']), tools=[PythonREPLTool()], handle_parsing_errors=True)
~~~

#### 3.2、高精度小数计算

~~~python
agent_executor.invoke({"input": "7的2.3次方是多少？"})
~~~

~~~sh
 Entering new AgentExecutor chain...
Python REPL can execute arbitrary code. Use with caution.
We can use Python to calculate 7 to the power of 2.3.
Action: Python_REPL
Action Input: print(7 ** 2.3)
Observation: 87.84670816352883

Thought:The result of 7 to the power of 2.3 is approximately 87.85.
Final Answer: 87.85

> Finished chain.
{'input': '7的2.3次方是多少？', 'output': '87.85'}
~~~

**内部逻辑**：

- **推理**：需要高精度计算，应生成 Python 代码。
- **行动**：生成代码`print(7 ** 2.3)`。

- **观察**：执行代码得到结果`87.85`。
- **输出**：返回计算结果。

#### 3.3、斐波那契数列求解

~~~python
agent_executor.invoke({"input": "第12个斐波那契数列的数字是多少？"})
~~~

~~~sh
> Entering new AgentExecutor chain...
我们可以使用循环或递归来计算斐波那契数列的第12个数字。
Action: Python_REPL
Action Input: def fibonacci(n):
                if n <= 1:
                    return n
                else:
                    return fibonacci(n-1) + fibonacci(n-2)
            print(fibonacci(12))
Observation: IndentationError('unindent does not match any outer indentation level', ('<string>', 6, 33, '            print(fibonacci(12))\n', 6, -1))
Thought:There was an indentation error in the code. Let me fix it and try again.
Action: Python_REPL
Action Input: def fibonacci(n):
                if n <= 1:
                    return n
                else:
                    return fibonacci(n-1) + fibonacci(n-2)
print(fibonacci(12))
Observation: 144

Thought:The 12th number in the Fibonacci sequence is 144.
Final Answer: 144

> Finished chain.
{'input': '第12个斐波那契数列的数字是多少？', 'output': '144'}
~~~

**内部逻辑**：

- **推理**：“需编写递归 / 循环函数计算，直接口算易出错。”

- **行动**：生成代码（首次因缩进错误报错，自动修正后重试）：

  ~~~python
  def fibonacci(n):
      if n == 0:
          return 0
      elif n == 1:
          return 1
      else:
          return fibonacci(n-1) + fibonacci(n-2)
  print(fibonacci(12))
  ~~~

- **观察**：执行代码返回`144`。
- **输出**：返回结果。

### 4、关键优势与适用场景

1. **计算准确性**：代码执行结果远优于模型直接猜测，尤其适合金融、科学等高精度场景。
2. **错误自修复**：通过`handle_parsing_errors=True`，Agent 可自动修正代码语法错误（如缩进、变量名）。
3. **扩展性强**：除数学计算外，还可处理数据可视化（如生成图表）、文件读写等任务。



## 四、Tool 用现成的AI工具分析数据表格

CSV（逗号分隔值）是常用的数据存储格式，借助 LangChain 提供的`create_csv_agent`，可快速构建能分析 CSV 数据的 AI 助手，自动回答 “数据行数、平均值、变量含义” 等问题。以下是具体实现与功能说明：

### 1、前期准备：依赖安装与 CSV 格式

#### 1. 安装必要库

CSV Agent 依赖数据分析工具和实验性模块，需提前安装：

~~~sh
pip install langchain-experimental pandas tabulate  # pandas处理数据，tabulate格式化输出
~~~

#### 2. CSV 格式说明

- **本质**：纯文本文件，用英文逗号分隔数据（如`姓名,年龄,性别`）；
- **特点**：可被 Excel、Python 等工具解析为表格，适合存储结构化数据（如房屋价格、用户信息）。

### 2、创建 CSV Agent 执行器

通过`create_csv_agent`函数快速构建 Agent，无需手动定义工具和提示模板：

#### 1. 核心代码

~~~python
from langchain_openai import ChatOpenAI
from langchain_experimental.agents import create_csv_agent

# 1. 初始化大语言模型（低随机性，确保代码可靠）
llm = ChatOpenAI(
    model_name="gpt-3.5-turbo",
    openai_api_key="你的API密钥",
    temperature=0
)

# 2. 创建CSV Agent执行器（指定CSV文件路径）
agent_executor = create_csv_agent(
    llm=llm,
    path="house_price.csv",  # 你的CSV文件路径（如房屋数据）
    verbose=True,  # 打印思考与执行过程
    agent_executor_kwargs={"handle_parsing_errors": True}  # 自动处理代码错误
)
~~~

#### 2. Agent 的核心能力

- **内置工具**：集成`PythonREPLTool`（执行 Python 代码）和`pandas`（分析 CSV 数据，生成`DataFrame`）；
- **提示模板**：引导 AI 遵循 REACT 框架，通过`pandas`代码（如`df.shape`、`df.mean()`）分析数据，而非直接猜测答案。

### 3、实战案例：用 CSV Agent 分析房屋数据

以 “[house_price.csv](https://github.com/Daneliya/python_study_project)”（包含房屋面积、价格、户型等信息）为例，展示 Agent 的使用场景：

#### 1. 基础查询：数据行数与变量

~~~python
# 问题1：数据集有多少行？
response1 = agent_executor.invoke({
    "input": "数据集有多少行？用中文回答"
})
print(response1["output"])  # 输出：该数据集共有1000行数据。

# 问题2：数据集包含哪些变量？
response2 = agent_executor.invoke({
    "input": "数据集包含哪些变量？用中文回复"
})
print(response2["output"])  # 输出：数据集包含的变量有：price, area, bedrooms, bathrooms, stories, mainroad, guestroom, basement, hotwaterheating, airconditioning, parking, prefarea, furnishingstatus
~~~

**执行逻辑**：

- 调用`pandas`代码`df.shape[0]`（行数）和`df.columns`（列名），确保结果准确。

#### 2. 计算查询：价格平均值

~~~python
# 问题3：数据集里，所有房子的价格平均值是多少？
response3 = agent_executor.invoke({
    "input": "数据集里，所有房子的价格平均值是多少？用中文回复"
})
print(response3["output"])  # 输出：所有房子的价格平均值是4766729.25
~~~

**执行逻辑**：

- 生成代码`df['价格'].mean()`，执行后返回计算结果（避免模型直接口算出错）。

#### 3. 综合分析：变量含义与数据特征

~~~python
# 问题4：数据集里，所有房子的装修状态包含哪些种类？你认为它们具体表示什么意思？
response4 = agent_executor.invoke({
    "input": "数据集里，所有房子的装修状态包含哪些种类？你认为它们具体表示什么意思？用中文回复"
})
print(response4["output"])
# 输出：装修状态包括'furnished'（已装修）、'semi-furnished'（半装修）和'unfurnished'（未装修）。它们分别表示房子的装修程度。
~~~

**执行逻辑**：

- 先通过`df['户型'].unique()`获取取值，再结合常识解释含义（融合代码执行结果与推理）。

### 4、优势与扩展

1. **准确性**：基于`pandas`代码执行结果回答，避免 “数据幻觉”（如错误的平均值、行数）；
2. **扩展性**：支持复杂分析（如分组统计`df.groupby('户型')['价格'].mean()`、绘图`df.plot()`）；
3. **易用性**：无需手动编写数据分析代码，适合非技术人员快速获取数据洞察。

### 5、其他开箱即用的 Agent

LangChain 还提供类似工具，如：

- `create_pandas_dataframe_agent`：直接分析`pandas DataFrame`（无需 CSV 文件）；
- `create_sql_agent`：连接数据库（如 MySQL），通过 SQL 查询分析数据。

通过 CSV Agent，可快速构建 “零代码” 数据分析师，让 AI 自动处理 CSV 文件，回答从基础统计到综合分析的各类问题。



## 五、Tools 如何多个工具组成AI工具箱

LangChain 允许将多种工具（包括自定义工具、Python Agent、CSV Agent 等）集成到同一个 Agent 中，实现 “一 Agent 多能力”。通过这种方式，AI 可根据问题自动选择最合适的工具，解决更复杂的任务。以下是具体实现与核心逻辑：

### 1、多工具集成的核心思路

目标：让 Agent 同时具备 “文本字数计算”“执行 Python 代码”“分析 CSV 数据” 等能力，步骤如下：

1. **整合工具资源**：将自定义工具、已有 Agent（如 Python Agent、CSV Agent）统一封装为 “工具列表”；
2. **统一调度逻辑**：通过 Agent 执行器协调工具调用，让 AI 根据问题推理并选择工具；
3. **保持对话连续性**：通过对话记忆实现多轮交互，支持上下文关联的复杂问题。

### 2、实现步骤：集成多工具的 Agent

~~~python
# -------------------------- 1. 导入所需模块 --------------------------
from langchain import hub  # 用于获取提示模板
from langchain.agents import create_structured_chat_agent, AgentExecutor  # 创建结构化聊天Agent和执行器
from langchain.memory import ConversationBufferMemory  # 对话记忆（保存历史对话）
from langchain.tools import BaseTool, Tool  # 工具基类和工具封装类
from langchain_experimental.agents.agent_toolkits import create_csv_agent, create_python_agent  # 现成的CSV和Python Agent
from langchain_experimental.tools import PythonREPLTool  # Python解释器工具
from langchain_openai import ChatOpenAI  # OpenAI聊天模型

# -------------------------- 2. 封装工具列表 --------------------------
# 自定义文本字数计算工具（继承BaseTool）
class TextLengthTool(BaseTool):
    name = "文本字数计算工具"  # 工具名称
    description = "当你需要计算文本包含的字数时，使用此工具"  # 工具功能描述（帮助Agent判断何时使用）

    # 工具核心逻辑：返回输入文本的长度
    def _run(self, text):
        return len(text)
        
# 创建Python代码执行Agent（用于执行Python代码解决计算问题）
python_agent_executor = create_python_agent(
    llm=ChatOpenAI(model="gpt-3.5-turbo", temperature=0),  # 低随机性模型，确保代码可靠
    tool=PythonREPLTool(),  # 内置Python解释器工具
    verbose=True,  # 打印代码执行过程
    agent_executor_kwargs={"handle_parsing_errors": True}  # 自动处理代码解析错误
)

# 创建CSV分析Agent（用于分析house_price.csv数据）
csv_agent_executor = create_csv_agent(
    llm=ChatOpenAI(model="gpt-3.5-turbo", temperature=0),  # 低随机性模型
    path="house_price.csv",  # 目标CSV文件路径
    verbose=True,  # 打印分析过程
    agent_executor_kwargs={"handle_parsing_errors": True}  # 自动处理解析错误
)

# 工具列表：整合自定义工具和封装好的Agent
tools=[
    # 封装Python Agent为工具
    Tool(
        name="Python代码工具",  # 工具名称
        description="""当你需要借助Python解释器时，使用这个工具。
        用自然语言把要求给这个工具，它会生成Python代码并返回代码执行的结果。""",  # 功能描述
        func=python_agent_executor.invoke  # 调用Python Agent的invoke方法
    ),
    # 封装CSV Agent为工具
    Tool(
        name="CSV分析工具",  # 工具名称
        description="""当你需要回答有关house_price.csv文件的问题时，使用这个工具。
        它接受完整的问题作为输入，在使用Pandas库计算后，返回答案。""",  # 功能描述
        func=csv_agent_executor.invoke  # 调用CSV Agent的invoke方法
    ),
    TextLengthTool()  # 加入自定义的文本字数计算工具
]

# -------------------------- 3. 创建多工具 Agent 执行器 --------------------------
# 初始化基础大语言模型（作为Agent的"大脑"）
model = ChatOpenAI(model='gpt-3.5-turbo')

# 初始化对话记忆（保存历史对话，支持多轮交互）
memory = ConversationBufferMemory(
    memory_key='chat_history',  # 记忆在Agent中的键名
    return_messages=True  # 以消息对象形式存储（而非字符串）
)

# 从LangChainHub获取结构化聊天Agent的提示模板（遵循REACT框架）
prompt = hub.pull("hwchase17/structured-chat-agent")
prompt  # 查看模板内容（引导Agent推理、选择工具）

# 创建多工具集成的结构化聊天Agent
agent = create_structured_chat_agent(
    llm=model,  # 基础模型
    tools=tools,  # 可用工具列表
    prompt=prompt  # 提示模板
)

# 创建Agent执行器（调度Agent和工具，处理实际任务）
agent_executor = AgentExecutor.from_agent_and_tools(
    agent=agent,  # 上述创建的Agent
    tools=tools,  # 工具列表
    memory=memory,  # 对话记忆（支持多轮对话）
    verbose=True,  # 打印详细过程（推理、工具调用、结果）
    handle_parsing_errors=True  # 自动处理Agent输出解析错误
)
~~~

### 3、实战测试：多工具 Agent 的能力验证

以 “文本字数计算”“Python 代码执行”“CSV 分析” 三类问题为例，验证 Agent 的工具选择能力：

~~~python
# 1. 调用文本字数计算工具
# 逻辑：Agent 识别到 “字数计算” 需求，自动选择文本字数计算工具。
agent_executor.invoke({"input": "'君不见黄河之水天上来奔流到海不复回'，这句话的字数是多少？"})

# 2. 调用 Python 代码执行工具
# 逻辑：Agent 判断需要复杂计算，选择Python代码执行工具，生成代码2**10 + 100并执行。
agent_executor.invoke({"input": "第8个斐波那契数列的数字是多少？"})

# 3. 调用 CSV 分析工具
# 逻辑：Agent 识别到 “CSV 数据处理” 需求，选择CSV分析工具，通过pandas代码df['价格'].median()获取结果。
agent_executor.invoke({"input": "house_price数据集里，所有房子的价格平均值是多少？用中文回答"})
~~~

### 4、优势与扩展

1.**能力复用**：无需重复开发，直接整合已有 Agent（如 Python Agent、CSV Agent）；
2.**智能选择**：AI 根据问题类型自动匹配工具（如计算用 Python 工具，统计用 CSV 工具）；
3.**扩展性强**：可继续添加工具（如搜索引擎、API 调用），逐步增强 Agent 能力。

通过多工具集成，Agent 从 “单一功能” 升级为 “多功能助手”，能应对更复杂的场景（如结合文本分析、数据计算、文件处理的综合任务）。